<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CLINICAL CIRCUMFERENCE - ICD-10 Defense Protocol</title>
    <style>
        body {
            margin: 0;
            background: #050508;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Courier New', 'Segoe UI', sans-serif;
            overflow: hidden;
            color: #00f5ff;
        }
        
        #main-container {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 20px;
            position: relative;
        }
        
        #info-panel {
            width: 380px;
            height: 900px;
            background: #050508;
            border: 2px solid #1a1a2e;
            border-radius: 8px;
            box-shadow: 0 0 50px rgba(255, 0, 110, 0.3);
            position: relative;
            overflow: hidden;
            cursor: default;
        }
        
        #game-container {
            position: relative;
            width: 900px;
            height: 900px;
            box-shadow: 0 0 50px rgba(255, 0, 110, 0.3);
            border: 2px solid #1a1a2e;
            border-radius: 8px;
            background: #050508;
        }
        
        canvas {
            display: block;
        }
        
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        #health-bar {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 28px;
            background: #1a1a2e;
            border: 2px solid #ff006e;
            border-radius: 14px;
            overflow: hidden;
            z-index: 5;
        }
        
        #health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff006e, #ff4081);
            width: 100%;
            transition: width 0.3s;
            box-shadow: 0 0 20px #ff006e;
        }
        
        #core-label {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: #ff006e;
            text-shadow: 0 0 5px #ff006e;
            background: rgba(0,0,0,0.8);
            padding: 2px 10px;
            border-radius: 2px;
            z-index: 5;
        }
        
        .warning {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 220px;
            color: #ff3333;
            font-size: 18px;
            font-weight: bold;
            opacity: 0;
            pointer-events: none;
            text-shadow: 0 0 20px #ff0000;
            background: rgba(0,0,0,0.95);
            padding: 20px;
            border: 3px solid #ff0000;
            border-radius: 8px;
            text-align: center;
            animation: flankPulse 0.6s ease-in-out;
            z-index: 100;
        }
        
        .warning.left-flank {
            left: 30px;
            border-left: 8px solid #ff0000;
        }
        
        .warning.right-flank {
            right: 30px;
            border-right: 8px solid #ff0000;
        }
        
        @keyframes flankPulse {
            0% { opacity: 0; transform: translateY(-50%) translateX(20px); }
            15% { opacity: 1; transform: translateY(-50%) translateX(0); }
            85% { opacity: 1; transform: translateY(-50%) translateX(0); }
            100% { opacity: 0; transform: translateY(-50%) translateX(-20px); }
        }
        
        #controls-hint {
            position: absolute;
            top: 30px;
            right: 30px;
            text-align: right;
            color: rgba(255,255,255,0.6);
            font-size: 11px;
            line-height: 1.6;
            z-index: 5;
        }

        #btn-settings-toggle {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00f5ff;
            color: #00f5ff;
            padding: 8px 15px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            z-index: 210;
            pointer-events: auto;
            border-radius: 4px;
        }
        
        #btn-settings-toggle:hover {
            background: #00f5ff;
            color: #000;
        }
        
        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 8, 0.98);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            pointer-events: auto;
        }
        
        /* Modal for Quiz & Stats & Settings */
        #quiz-modal, #stats-modal, #settings-modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 8, 0.98);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
            pointer-events: auto;
        }

        .quiz-content {
            width: 80%;
            max-width: 600px;
            background: #0f0f1a;
            border: 2px solid #ffd700;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.2);
        }

        .settings-content {
            width: 500px;
            background: #0f0f1a;
            border: 2px solid #00f5ff;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 245, 255, 0.2);
        }

        .settings-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .settings-label {
            color: #fff;
            font-family: 'Segoe UI', sans-serif;
            font-size: 16px;
        }

        .settings-value {
            color: #00f5ff;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            width: 60px;
            text-align: right;
        }

        input[type=range] {
            width: 200px;
            accent-color: #00f5ff;
        }

        .quiz-question {
            font-size: 20px;
            color: #fff;
            margin-bottom: 25px;
            text-align: center;
            line-height: 1.4;
        }

        .quiz-options {
            display: grid;
            gap: 15px;
        }

        .quiz-btn {
            background: rgba(0, 245, 255, 0.1);
            border: 1px solid #00f5ff;
            color: #00f5ff;
            padding: 15px;
            font-family: 'Segoe UI', sans-serif;
            font-size: 14px;
            cursor: pointer;
            text-align: left;
            transition: all 0.2s;
        }

        .quiz-btn:hover {
            background: #00f5ff;
            color: #000;
        }

        /* Stats specific styles */
        .stats-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
            border-bottom: 1px solid #333;
            padding-bottom: 5px;
        }
        .stats-label { color: #aaa; font-size: 14px; }
        .stats-value { color: #fff; font-weight: bold; font-family: 'Courier New', monospace; }
        
        .title {
            font-size: 48px;
            letter-spacing: 6px;
            color: #00f5ff;
            text-shadow: 0 0 40px #00f5ff;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .subtitle {
            font-size: 16px;
            color: #ff006e;
            margin-bottom: 50px;
            max-width: 600px;
            text-align: center;
            line-height: 1.8;
        }
        
        .difficulty-btn {
            background: transparent;
            border: 2px solid #00f5ff;
            color: #00f5ff;
            padding: 18px 50px;
            margin: 12px;
            font-family: 'Courier New', monospace;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 3px;
        }
        
        .difficulty-btn:hover {
            background: #00f5ff;
            color: #000;
            box-shadow: 0 0 40px #00f5ff;
            transform: scale(1.05);
        }
        
        .difficulty-btn.hard {
            border-color: #ff006e;
            color: #ff006e;
        }
        
        .difficulty-btn.hard:hover {
            background: #ff006e;
            color: #fff;
            box-shadow: 0 0 40px #ff006e;
        }

        .cert-btn {
            border-color: #ffd700;
            color: #ffd700;
        }
        
        .cert-btn:hover {
            background: #ffd700;
            color: #000;
            box-shadow: 0 0 40px #ffd700;
        }

        .reset-btn {
            border-color: #ff3333;
            color: #ff3333;
            font-size: 14px;
            padding: 10px 30px;
            margin-top: 30px;
            opacity: 0.7;
        }

        .reset-btn:hover {
            background: #ff3333;
            color: #fff;
            box-shadow: 0 0 30px #ff3333;
            opacity: 1;
        }
        
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div id="main-container">
        <div id="info-panel">
            <canvas id="info-canvas" width="380" height="900"></canvas>
        </div>
        
        <div id="game-container">
            <canvas id="game" width="900" height="900"></canvas>
            
            <div id="ui-layer">
                <button id="btn-settings-toggle" onclick="openSettings()">SETTINGS [ESC]</button>
                
                <div id="health-bar" class="hidden">
                    <div id="health-fill"></div>
                </div>
                <div id="core-label" class="hidden">CLINICAL INTEGRITY</div>
                
                <div id="controls-hint" class="hidden">
                    <div style="color:#ffd700; margin-bottom:5px">★ GOLD = HCC HIGH VALUE</div>
                    <div style="color:#39ff14; margin-bottom:5px">★ STAR = SHARED SAVINGS</div>
                    [A] Rotate CCW | [S] Rotate CW<br>
                    [MOUSE] Aim | [CLICK] Fire<br>
                    <span style="color:#fff;">CLICK SIDE PANEL TO SOLIDIFY MEMORY</span>
                </div>
                
                <div id="warning-container"></div>
            </div>
            
            <!-- Settings Modal -->
            <div id="settings-modal" class="hidden">
                <div class="settings-content">
                    <div class="title" style="font-size:28px; margin-bottom:15px; color:#00f5ff;">SYSTEM CONFIGURATION</div>
                    
                    <div class="settings-row">
                        <span class="settings-label">Target Regime Duration (Sec)</span>
                        <input type="range" id="opt-duration" min="5" max="60" value="20" oninput="updateSettingsUI()">
                        <span id="val-duration" class="settings-value">20</span>
                    </div>

                    <div class="settings-row">
                        <span class="settings-label">Rotation Sensitivity</span>
                        <input type="range" id="opt-rotation" min="1" max="10" value="3" oninput="updateSettingsUI()">
                        <span id="val-rotation" class="settings-value">3</span>
                    </div>

                    <div class="settings-row">
                        <span class="settings-label">Audio Speech Synthesis</span>
                        <div style="width:200px; text-align:left;">
                            <input type="checkbox" id="opt-speech" checked style="accent-color:#00f5ff; transform:scale(1.5);">
                        </div>
                        <span class="settings-value"></span>
                    </div>

                    <div class="quiz-options" style="margin-top:30px;">
                        <button class="difficulty-btn" style="font-size:16px; padding:10px; width:100%;" onclick="closeSettings()">Confirm Configuration</button>
                    </div>
                </div>
            </div>
            
            <!-- Stats Modal -->
            <div id="stats-modal" class="hidden">
                <div class="quiz-content" style="border-color: #00f5ff; box-shadow: 0 0 30px rgba(0, 245, 255, 0.2);">
                    <div class="title" style="font-size:28px; margin-bottom:15px; color:#00f5ff;">MEMORY DIAGNOSTIC</div>
                    <div id="stats-content">
                        <!-- Injected via JS -->
                    </div>
                    <div class="quiz-options" style="margin-top:20px; grid-template-columns: 1fr 1fr;">
                        <button class="difficulty-btn" style="font-size:16px; padding:10px;" onclick="closeStats()">Resume</button>
                        <button id="btn-solidify" class="difficulty-btn cert-btn" style="font-size:16px; padding:10px;" onclick="proceedToQuiz()">Initiate Solidification</button>
                    </div>
                </div>
            </div>

            <!-- Quiz Modal -->
            <div id="quiz-modal" class="hidden">
                <div class="quiz-content">
                    <div class="title" style="font-size:24px; margin-bottom:10px; color:#ffd700;">MEMORY SOLIDIFICATION</div>
                    <div id="quiz-step-indicator" style="color:#aaa; margin-bottom:20px; text-align:center;">PROTOCOL CHECK: PHASE 1/2</div>
                    <div id="quiz-question-text" class="quiz-question">Identify the clinical entity: E11.9</div>
                    <div id="quiz-options-container" class="quiz-options">
                        <!-- Options injected via JS -->
                    </div>
                </div>
            </div>

            <div id="start-screen">
                <div class="title">CLINICAL CIRCUMFERENCE</div>
                <div class="subtitle">
                    ICD-10/HCC Risk Adjustment Protocol<br>
                    Destroy <span style="color:#ffd700">HCC codes</span> for high value.<br>
                    <span style="color:#ff6600">TARGETS SHIFT.</span> Verify ICD-10, Diagnosis, and HCC Status.<br>
                    <span style="font-size:12px; color:#fff; margin-top:10px; display:block">CLICK mastered codes in the left panel to SOLIDIFY memory via protocol quiz.</span>
                </div>
                <button class="difficulty-btn" onclick="startGame('easy')">Residency (Slow, Few)</button>
                <button class="difficulty-btn" onclick="startGame('medium')">Attending (Fast, Swarm)</button>
                <button class="difficulty-btn hard" onclick="startGame('hard')">Chief (Critical Overload)</button>
                
                <button class="difficulty-btn reset-btn" onclick="resetProgress()">PURGE MEMORY CORE</button>
            </div>
            
            <div id="game-over-screen" class="hidden">
                <div class="title" style="color:#ff006e">DOCUMENTATION FAILURE</div>
                <div class="subtitle" id="final-score">Final RAF Score: 0</div>
                <div style="color:#ffd700; margin-bottom:30px; font-size:18px" id="final-words">HCC Captured: 0</div>
                <button class="difficulty-btn" onclick="location.reload()">Reboot EHR</button>
                <button class="difficulty-btn cert-btn" onclick="downloadCertificate()">Download Certificate</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const infoCanvas = document.getElementById('info-canvas');
        const infoCtx = infoCanvas.getContext('2d');
        const quizModal = document.getElementById('quiz-modal');
        const statsModal = document.getElementById('stats-modal');
        const settingsModal = document.getElementById('settings-modal');
        
        let gameState = 'start';
        let frame = 0;
        let score = 0;
        let coreHealth = 100;
        let difficulty = 'medium';
        let baseRotation = 0;
        let friendlyFireWarningCooldown = 0;
        let targetSwitchTimer = 0;
        
        // Settings State
        let gameSettings = {
            targetDuration: 20, // seconds
            rotationSpeed: 0.03,
            speechEnabled: true
        };

        const VOCAB_KEY = 'clinical_circumference_vocab';
        const LAST_DECAY_KEY = 'clinical_circumference_last_decay';
        
        // Memory Solidification State
        let quizState = { active: false, code: null, step: 0, correctAnswers: 0 };
        let infoPanelClickRegions = [];
        let selectedMemoryCode = null;

        // Central Visual Feedback State
        let centralFeedback = {
            active: false,
            code: '',
            dx: '',
            timer: 0,
            maxTime: 30 // Approx 0.5s at 60fps
        };

        function loadVocabulary() {
            const saved = localStorage.getItem(VOCAB_KEY);
            return saved ? JSON.parse(saved) : {};
        }
        
        function saveVocabulary(vocab) {
            localStorage.setItem(VOCAB_KEY, JSON.stringify(vocab));
        }
        
        function getLastDecayTime() {
            const saved = localStorage.getItem(LAST_DECAY_KEY);
            return saved ? parseInt(saved) : Date.now();
        }
        
        function saveLastDecayTime() {
            localStorage.setItem(LAST_DECAY_KEY, Date.now().toString());
        }

        function resetProgress() {
            if(confirm("WARNING: This will erase all clinical mastery data. Proceed?")) {
                localStorage.removeItem(VOCAB_KEY);
                localStorage.removeItem(LAST_DECAY_KEY);
                location.reload();
            }
        }
        
        let vocabularyBank = loadVocabulary();
        
        function processOfflineDecay() {
            const now = Date.now();
            const lastDecay = getLastDecayTime();
            const hoursPassed = (now - lastDecay) / (1000 * 60 * 60);
            
            if (hoursPassed < 0.01) return;
            
            for (let code in vocabularyBank) {
                const entry = vocabularyBank[code];
                if (entry.mastery <= 0) continue;
                
                let hourlyDecay = 1.0;
                if (entry.solidified) hourlyDecay = 0.1; // Solidified memories decay very slowly
                else if (entry.mastery >= 70) hourlyDecay = 0.05;
                else if (entry.mastery >= 30) hourlyDecay = 0.3;
                
                if (entry.hccWeight > 1.0) hourlyDecay *= 0.5;
                
                const totalDecay = hourlyDecay * hoursPassed;
                entry.mastery = Math.max(0, entry.mastery - totalDecay);
            }
            
            saveVocabulary(vocabularyBank);
            saveLastDecayTime();
        }
        
        processOfflineDecay();
        
        const center = { x: 450, y: 450 };
        const arenaRadius = 380;
        const laserColors = ['#ff006e', '#00f5ff', '#39ff14', '#ffcc00', '#ff4081', '#9d4edd'];
        
        const icdDatabase = [
            { code: 'I50.9', dx: 'Heart Failure, unspecified', hccWeight: 0.331, isHCC: true, criticalFacts: ['EF < 40% qualifies for HCC', 'Beta-blocker mandatory', 'Daily weights required'], advancesSharedSavings: true, category: 'Cardiology' },
            { code: 'J44.1', dx: 'COPD w/ acute exacerbation', hccWeight: 0.348, isHCC: true, criticalFacts: ['Smoking cessation mandatory', 'Home O2 eval if PaO2 < 55', 'Pneumovax needed'], advancesSharedSavings: true, category: 'Pulmonary' },
            { code: 'N18.6', dx: 'End Stage Renal Disease', hccWeight: 0.585, isHCC: true, criticalFacts: ['eGFR < 15 ml/min', 'Fistula check required', 'Phosphate binder compliance'], advancesSharedSavings: true, category: 'Nephrology' },
            { code: 'E11.69', dx: 'T2DM with other specified comp', hccWeight: 0.302, isHCC: true, criticalFacts: ['Links diabetes to manifestation', 'Strict Glycemic control', 'Foot exam mandatory'], advancesSharedSavings: true, category: 'Endocrine' },
            { code: 'Z51.11', dx: 'Chemotherapy Encounter', hccWeight: 2.386, isHCC: true, criticalFacts: ['Neutropenic precautions', 'Active malignancy status', 'Nutrition consult'], advancesSharedSavings: true, category: 'Oncology' },
            { code: 'I48.0', dx: 'Paroxysmal Atrial Fibrillation', hccWeight: 0.268, isHCC: true, criticalFacts: ['CHADS-VASC score', 'Anticoagulation adherence', 'Rate control strategy'], advancesSharedSavings: true, category: 'Cardiology' },
            { code: 'F32.9', dx: 'Major Depressive Disorder', hccWeight: 0.330, isHCC: true, criticalFacts: ['PHQ-9 Annual Screen', 'Suicide risk assessment', 'Medication adherence'], advancesSharedSavings: false, category: 'Psychiatry' },
            { code: 'M06.9', dx: 'Rheumatoid Arthritis, unsp', hccWeight: 0.421, isHCC: true, criticalFacts: ['DMARD monitoring', 'Functional status exam', 'Cardiovascular risk'], advancesSharedSavings: false, category: 'Rheumatology' },
            { code: 'E43', dx: 'Unspecified Severe Malnutrition', hccWeight: 0.545, isHCC: true, criticalFacts: ['BMI < 18.5', 'Dietary supplements', 'Albumin monitoring'], advancesSharedSavings: true, category: 'Nutrition' },
            { code: 'Z93.0', dx: 'Tracheostomy Status', hccWeight: 0.880, isHCC: true, criticalFacts: ['Airway patency', 'Suction supplies', 'Infection risk'], advancesSharedSavings: true, category: 'Pulmonary' },
            { code: 'G20', dx: 'Parkinson disease', hccWeight: 0.279, isHCC: true, criticalFacts: ['Fall Risk Assessment', 'Swallowing eval', 'Carbidopa/Levo timing'], advancesSharedSavings: false, category: 'Neurology' },
            { code: 'I25.10', dx: 'ASHD without angina', hccWeight: 0.0, isHCC: false, criticalFacts: ['Statin therapy indicated', 'Aspirin use', 'BP Control < 130/80'], advancesSharedSavings: true, category: 'Cardiology' },
            { code: 'E11.9', dx: 'Type 2 Diabetes no comp', hccWeight: 0.0, isHCC: false, criticalFacts: ['A1c < 7.0 target', 'Annual retinal exam', 'Microalbumin urine test'], advancesSharedSavings: true, category: 'Endocrine' },
            { code: 'I10', dx: 'Essential Hypertension', hccWeight: 0.0, isHCC: false, criticalFacts: ['BP < 130/80 (ACC/AHA)', 'Dash diet counseling', 'Creatinine monitoring'], advancesSharedSavings: true, category: 'Cardiology' },
            { code: 'E78.5', dx: 'Hyperlipidemia, unsp', hccWeight: 0.0, isHCC: false, criticalFacts: ['ASCVD risk calculation', 'High intensity statin', 'Lifestyle modification'], advancesSharedSavings: true, category: 'Cardiology' },
            { code: 'E66.01', dx: 'Morbid Obesity', hccWeight: 0.250, isHCC: true, criticalFacts: ['BMI > 40', 'Bariatric referral', 'Sleep apnea screen'], advancesSharedSavings: true, category: 'Endocrine' },
            { code: 'J45.909', dx: 'Unspecified Asthma', hccWeight: 0.0, isHCC: false, criticalFacts: ['Inhaler technique check', 'Action plan provided', 'Flu shot indicated'], advancesSharedSavings: true, category: 'Pulmonary' },
            { code: 'K21.9', dx: 'GERD without esophagitis', hccWeight: 0.0, isHCC: false, criticalFacts: ['PPI indications', 'Lifestyle changes', 'H. Pylori check'], advancesSharedSavings: false, category: 'GI' },
            { code: 'M54.5', dx: 'Low back pain', hccWeight: 0.0, isHCC: false, criticalFacts: ['Conservative mgmt', 'Red flag screening', 'PT referral'], advancesSharedSavings: false, category: 'Ortho' },
            { code: 'N39.0', dx: 'UTI, site not specified', hccWeight: 0.0, isHCC: false, criticalFacts: ['Culture sensitivity', 'Antibiotic stewardship', 'Hydration'], advancesSharedSavings: true, category: 'Urology' },
            { code: 'F41.1', dx: 'Generalized Anxiety Disorder', hccWeight: 0.0, isHCC: false, criticalFacts: ['GAD-7 Score', 'CBT Referral', 'Benzodiazepine caution'], advancesSharedSavings: false, category: 'Psychiatry' },
            { code: 'D64.9', dx: 'Anemia, unspecified', hccWeight: 0.0, isHCC: false, criticalFacts: ['Ferritin/Iron studies', 'Colon cancer screen', 'B12/Folate check'], advancesSharedSavings: true, category: 'Hematology' },
            { code: 'E03.9', dx: 'Hypothyroidism, unsp', hccWeight: 0.0, isHCC: false, criticalFacts: ['TSH monitoring', 'Synthroid compliance', 'Take on empty stomach'], advancesSharedSavings: false, category: 'Endocrine' },
            { code: 'R73.03', dx: 'Prediabetes', hccWeight: 0.0, isHCC: false, criticalFacts: ['Metformin consideration', 'DPP lifestyle program', 'Annual A1c'], advancesSharedSavings: true, category: 'Endocrine' },
            { code: 'Z00.00', dx: 'Adult general exam', hccWeight: 0.0, isHCC: false, criticalFacts: ['Preventive focus', 'Cancer screenings', 'Immunization update'], advancesSharedSavings: true, category: 'Primary Care' },
            { code: 'G47.33', dx: 'Obstructive Sleep Apnea', hccWeight: 0.0, isHCC: false, criticalFacts: ['CPAP Compliance', 'Driver safety', 'Pulmonary HTN risk'], advancesSharedSavings: true, category: 'Pulmonary' },
            { code: 'I87.2', dx: 'Venous Insufficiency', hccWeight: 0.0, isHCC: false, criticalFacts: ['Compression stockings', 'Ulcer prevention', 'Leg elevation'], advancesSharedSavings: false, category: 'Vascular' },
            { code: 'L03.90', dx: 'Cellulitis, unsp', hccWeight: 0.0, isHCC: false, criticalFacts: ['Mark borders', 'Antibiotic choice', 'Diabetic foot check'], advancesSharedSavings: true, category: 'Dermatology' },
            { code: 'M17.11', dx: 'Unilat prim OA, right knee', hccWeight: 0.0, isHCC: false, criticalFacts: ['Weight loss helpful', 'Injection options', 'Total knee referral'], advancesSharedSavings: false, category: 'Ortho' },
            { code: 'Z12.11', dx: 'Encounter screen malig colon', hccWeight: 0.0, isHCC: false, criticalFacts: ['Colonoscopy q10y', 'Cologuard options', 'Family history'], advancesSharedSavings: true, category: 'GI' },
            { code: 'B35.1', dx: 'Tinea unguium', hccWeight: 0.0, isHCC: false, criticalFacts: ['Liver fx w/ oral meds', 'Topical limitations', 'Foot hygiene'], advancesSharedSavings: false, category: 'Dermatology' },
            { code: 'H25.11', dx: 'Age-rel nuc cataract, rt', hccWeight: 0.0, isHCC: false, criticalFacts: ['Visual acuity check', 'Fall risk increase', 'Surgery referral'], advancesSharedSavings: false, category: 'Ophthalmology' },
            { code: 'H91.90', dx: 'Unspecified hearing loss', hccWeight: 0.0, isHCC: false, criticalFacts: ['Audiology referral', 'Cognitive decline risk', 'Social isolation'], advancesSharedSavings: false, category: 'ENT' },
            { code: 'R05', dx: 'Cough', hccWeight: 0.0, isHCC: false, criticalFacts: ['ACE inhibitor check', 'GERD etiology', 'CXR if chronic'], advancesSharedSavings: false, category: 'Primary Care' },
            { code: 'R00.0', dx: 'Tachycardia, unsp', hccWeight: 0.0, isHCC: false, criticalFacts: ['Thyroid check', 'Anemia check', 'Holter monitor'], advancesSharedSavings: false, category: 'Cardiology' },
            { code: 'M81.0', dx: 'Osteoporosis w/o fracture', hccWeight: 0.0, isHCC: false, criticalFacts: ['DEXA T-score <-2.5', 'Bisphosphonates', 'Ca + Vit D'], advancesSharedSavings: true, category: 'Rheumatology' },
            { code: 'K76.0', dx: 'Fatty (change of) liver', hccWeight: 0.0, isHCC: false, criticalFacts: ['Fibroscan indication', 'Weight loss key', 'Liver enzymes'], advancesSharedSavings: true, category: 'GI' },
            { code: 'N40.0', dx: 'BPH without LUTS', hccWeight: 0.0, isHCC: false, criticalFacts: ['PSA monitoring', 'Alpha blockers', '5-ARI therapy'], advancesSharedSavings: false, category: 'Urology' },
            { code: 'G43.909', dx: 'Migraine, unsp, not intractable', hccWeight: 0.0, isHCC: false, criticalFacts: ['Trigger avoidance', 'Triptan usage', 'Prophylaxis if freq'], advancesSharedSavings: false, category: 'Neurology' },
            { code: 'R60.0', dx: 'Localized edema', hccWeight: 0.0, isHCC: false, criticalFacts: ['Heart failure r/o', 'DVT check', 'Medication side effect'], advancesSharedSavings: true, category: 'Primary Care' },
            { code: 'B20', dx: 'HIV Disease', hccWeight: 0.383, isHCC: true, criticalFacts: ['CD4 Count', 'Viral Load', 'ART Compliance'], advancesSharedSavings: true, category: 'ID' },
            { code: 'C18.9', dx: 'Malignant neoplasm colon', hccWeight: 0.982, isHCC: true, criticalFacts: ['Staging CT', 'Oncology referral', 'CEA monitoring'], advancesSharedSavings: true, category: 'Oncology' }
        ];
        
        let activePool = [];
        let currentTarget = null;
        let targetIndex = 0;
        let decayFrameCounter = 0;
        
        const mouse = { x: 450, y: 450, active: false };
        const keys = {};
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
        });
        canvas.addEventListener('mousedown', () => mouse.active = true);
        canvas.addEventListener('mouseup', () => mouse.active = false);
        
        // Handle side panel clicks for Stats
        infoCanvas.addEventListener('mousedown', (e) => {
            const rect = infoCanvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left; // Added X check
            const clickY = e.clientY - rect.top;
            
            // Check click regions
            for (let region of infoPanelClickRegions) {
                // Now checks BOTH X and Y
                if (clickX >= region.x && clickX <= region.x + region.width && 
                    clickY >= region.y && clickY <= region.y + region.height) {
                    if (gameState === 'playing' || gameState === 'paused') {
                        openStatsModal(region.code);
                        break; // Stop loop on hit
                    }
                }
            }
        });

        window.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (e.code === 'Space') e.preventDefault();
            if (e.code === 'Escape') {
                if (!settingsModal.classList.contains('hidden')) closeSettings();
                else openSettings();
            }
        });
        window.addEventListener('keyup', (e) => keys[e.code] = false);
        
        const cannons = [];
        const aliens = [];
        const particles = [];
        
        function speakClinicalData(dxData) {
            if (!gameSettings.speechEnabled || !('speechSynthesis' in window)) return;
            window.speechSynthesis.cancel();
            
            const text = `${dxData.code}. ${dxData.dx}`;
            const codeUtterance = new SpeechSynthesisUtterance(text);
            codeUtterance.rate = 1.0;
            window.speechSynthesis.speak(codeUtterance);
        }

        function triggerCentralFeedback(dxData) {
            centralFeedback.active = true;
            centralFeedback.code = dxData.code;
            centralFeedback.dx = dxData.dx;
            centralFeedback.timer = centralFeedback.maxTime;
        }

        // --- SETTINGS UI ---
        function openSettings() {
            if (gameState === 'playing') gameState = 'paused';
            settingsModal.classList.remove('hidden');
            // Init UI
            document.getElementById('opt-duration').value = gameSettings.targetDuration;
            document.getElementById('val-duration').textContent = gameSettings.targetDuration;
            document.getElementById('opt-rotation').value = gameSettings.rotationSpeed * 100;
            document.getElementById('val-rotation').textContent = Math.round(gameSettings.rotationSpeed * 100);
            document.getElementById('opt-speech').checked = gameSettings.speechEnabled;
        }

        function closeSettings() {
            // Save from UI
            const dur = parseInt(document.getElementById('opt-duration').value);
            const rot = parseInt(document.getElementById('opt-rotation').value);
            const speech = document.getElementById('opt-speech').checked;

            gameSettings.targetDuration = dur;
            gameSettings.rotationSpeed = rot / 100;
            gameSettings.speechEnabled = speech;

            settingsModal.classList.add('hidden');
            
            if (gameState === 'paused') {
                gameState = 'playing';
                draw(); // RESTART RENDER LOOP
            } else {
                gameState = 'playing';
                draw();
            }
            
            // Reset timer to avoid immediate switch if duration reduced
            if (targetSwitchTimer > gameSettings.targetDuration * 60) {
                targetSwitchTimer = gameSettings.targetDuration * 60;
            }
        }

        function updateSettingsUI() {
            document.getElementById('val-duration').textContent = document.getElementById('opt-duration').value;
            document.getElementById('val-rotation').textContent = document.getElementById('opt-rotation').value;
        }

        // --- STATS & QUIZ LOGIC ---
        
        function openStatsModal(code) {
            if (gameState === 'playing') gameState = 'paused';
            selectedMemoryCode = code;
            const vocab = vocabularyBank[code];
            const dx = vocab.dxData;
            const content = document.getElementById('stats-content');
            const isSolid = vocab.solidified;
            
            if (isSolid) {
                // Show Full Stats
                content.innerHTML = `
                    <div style="font-size:48px; color:#ffd700; text-align:center; margin-bottom:10px; text-shadow:0 0 15px #ffd700; font-family:'Courier New'">${code}</div>
                    <div style="font-size:18px; color:#fff; text-align:center; margin-bottom:30px;">${dx.dx}</div>
                    
                    <div class="stats-row">
                        <span class="stats-label">PROTOCOL STATUS</span>
                        <span class="stats-value" style="color:#ffd700">SOLIDIFIED PROTOCOL</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">MEMORY MASTERY</span>
                        <div style="display:flex; align-items:center; gap:10px;">
                            <span class="stats-value">${Math.floor(vocab.mastery)}%</span>
                            <div style="width:100px; height:6px; background:#333; border-radius:3px;">
                                <div style="width:${vocab.mastery}%; height:100%; background:#ffd700; border-radius:3px;"></div>
                            </div>
                        </div>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">ENCOUNTERS</span>
                        <span class="stats-value">${vocab.hits}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">HCC WEIGHT</span>
                        <span class="stats-value">${dx.hccWeight}</span>
                    </div>
                `;
            } else {
                // Show Active Learning (Hidden DX)
                content.innerHTML = `
                    <div style="font-size:48px; color:#00f5ff; text-align:center; margin-bottom:10px; text-shadow:0 0 15px #00f5ff; font-family:'Courier New'">${code}</div>
                    <div style="font-size:18px; color:#aaa; text-align:center; margin-bottom:30px; letter-spacing:2px;">[DIAGNOSIS ENCRYPTED]</div>
                    
                    <div class="stats-row">
                        <span class="stats-label">PROTOCOL STATUS</span>
                        <span class="stats-value" style="color:#00f5ff">ACTIVE LEARNING</span>
                    </div>
                     <div style="margin-top:20px; color:#666; font-style:italic; text-align:center;">
                       Protocol data masked until verified.<br>
                       Initiate Solidification to reveal clinical details.
                    </div>
                `;
            }
            
            // Toggle Solidify Button
            const btn = document.getElementById('btn-solidify');
            if (isSolid) {
                btn.classList.add('hidden');
            } else {
                btn.classList.remove('hidden');
            }
            
            statsModal.classList.remove('hidden');
        }
        
        function closeStats() {
            statsModal.classList.add('hidden');
            gameState = 'playing';
            draw(); // RESTART RENDER LOOP
        }
        
        function proceedToQuiz() {
            statsModal.classList.add('hidden');
            startSolidifyQuiz(selectedMemoryCode);
        }

        function startSolidifyQuiz(code) {
            const vocab = vocabularyBank[code];
            if (!vocab) return;
            
            // Pause Game (redundant check but safe)
            if (gameState === 'playing') gameState = 'paused';
            
            quizState = {
                active: true,
                code: code,
                step: 1,
                dxData: vocab.dxData,
                correctAnswers: 0
            };
            
            quizModal.classList.remove('hidden');
            renderQuizStep();
        }

        function renderQuizStep() {
            const container = document.getElementById('quiz-options-container');
            container.innerHTML = '';
            const stepIndicator = document.getElementById('quiz-step-indicator');
            const questionText = document.getElementById('quiz-question-text');
            
            if (quizState.step === 1) {
                // Step 1: Identify Diagnosis
                stepIndicator.textContent = "PROTOCOL CHECK: PHASE 1/2";
                questionText.textContent = `Identify the clinical entity: ${quizState.code}`;
                
                // Generate Options
                let options = [quizState.dxData.dx];
                // Add distractors
                while (options.length < 4) {
                    const r = icdDatabase[Math.floor(Math.random() * icdDatabase.length)];
                    if (!options.includes(r.dx) && r.code !== quizState.code) options.push(r.dx);
                }
                shuffleArray(options);
                
                options.forEach(opt => {
                    const btn = document.createElement('button');
                    btn.className = 'quiz-btn';
                    btn.textContent = opt;
                    btn.onclick = () => submitQuizAnswer(opt === quizState.dxData.dx);
                    container.appendChild(btn);
                });
            } else if (quizState.step === 2) {
                // Step 2: Identify Best Practice
                stepIndicator.textContent = "PROTOCOL CHECK: PHASE 2/2";
                questionText.textContent = `Select the CRITICAL Best Practice for: ${quizState.dxData.dx}`;
                
                let correctFact = quizState.dxData.criticalFacts[0]; // Take first fact as key
                let options = [correctFact];
                
                while (options.length < 4) {
                    const r = icdDatabase[Math.floor(Math.random() * icdDatabase.length)];
                    const fact = r.criticalFacts[0];
                    if (!options.includes(fact) && r.code !== quizState.code) options.push(fact);
                }
                shuffleArray(options);
                
                options.forEach(opt => {
                    const btn = document.createElement('button');
                    btn.className = 'quiz-btn';
                    btn.textContent = opt;
                    btn.onclick = () => submitQuizAnswer(opt === correctFact);
                    container.appendChild(btn);
                });
            }
        }

        function submitQuizAnswer(isCorrect) {
            if (isCorrect) {
                if (quizState.step === 1) {
                    quizState.step = 2;
                    renderQuizStep();
                } else {
                    // Success!
                    completeQuiz(true);
                }
            } else {
                // Fail
                completeQuiz(false);
            }
        }

        function completeQuiz(success) {
            quizModal.classList.add('hidden');
            if (success) {
                // Solidify Logic
                if (vocabularyBank[quizState.code]) {
                    vocabularyBank[quizState.code].solidified = true;
                    vocabularyBank[quizState.code].solidifiedTime = Date.now();
                    vocabularyBank[quizState.code].mastery = 100; // Boost to 100
                    saveVocabulary(vocabularyBank);
                    score += 500; // Bonus
                    showWarning("MEMORY SOLIDIFIED", "right");
                    createExplosion(center.x, center.y, '#ffd700');
                }
            } else {
                showWarning("PROTOCOL FAILED", "left");
            }
            
            // Resume Game
            gameState = 'playing';
            quizState.active = false;
            draw(); // RESTART RENDER LOOP
        }
        
        class Cannon {
            constructor(index, total) {
                this.index = index;
                this.angle = (Math.PI * 2 / total) * index;
                this.targetAngle = 0;
                this.x = 0;
                this.y = 0;
                this.firing = false;
                this.cooldown = 0;
                this.range = arenaRadius * 1.3;
                this.integrity = 100;
                this.heat = 0;
                this.color = laserColors[index % laserColors.length];
                this.friendlyFireDamage = 0;
            }
            
            update() {
                const actualAngle = this.angle + baseRotation;
                const targetX = center.x + Math.cos(actualAngle) * arenaRadius;
                const targetY = center.y + Math.sin(actualAngle) * arenaRadius;
                this.x += (targetX - this.x) * 0.1;
                this.y += (targetY - this.y) * 0.1;
                const dx = mouse.x - this.x;
                const dy = mouse.y - this.y;
                let targetAng = Math.atan2(dy, dx);
                let diff = targetAng - this.targetAngle;
                while (diff > Math.PI) diff -= Math.PI * 2;
                while (diff < -Math.PI) diff += Math.PI * 2;
                this.targetAngle += diff * 0.1;
                
                if (mouse.active && this.cooldown <= 0 && this.integrity > 0) {
                    this.firing = !this.firing;
                    this.cooldown = 10;
                }
                if (this.cooldown > 0) this.cooldown--;
                if (this.firing) {
                    this.integrity -= 0.05;
                    this.heat += 1.5;
                    if (this.heat > 100) {
                        this.firing = false;
                        showWarning("CANNON OVERHEAT!", "right");
                    }
                } else {
                    this.heat = Math.max(0, this.heat - 1);
                    if (this.heat === 0 && this.integrity < 100) this.integrity += 0.08;
                }
                this.integrity = Math.max(0, Math.min(100, this.integrity));
            }
            
            draw() {
                const barWidth = 36, barHeight = 3, barX = this.x - barWidth/2, barY = this.y - 30;
                ctx.fillStyle = '#111';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                const healthPct = this.integrity / 100;
                ctx.fillStyle = healthPct > 0.6 ? '#39ff14' : healthPct > 0.3 ? '#ffcc00' : '#ff006e';
                ctx.fillRect(barX, barY, barWidth * healthPct, barHeight);
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.targetAngle);
                ctx.fillStyle = this.integrity > 0 ? this.color : '#333';
                ctx.shadowBlur = this.integrity > 30 ? 12 : 4;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.arc(0, 0, 20, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = this.integrity > 30 ? '#fff' : '#666';
                ctx.fillRect(0, -8, 35, 16);
                if (this.firing && this.integrity > 0) {
                    ctx.fillStyle = '#fff';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#fff';
                    ctx.beginPath();
                    ctx.arc(0, 0, 8, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            }
            
            drawLaser() {
                if (!this.firing || this.integrity <= 0) return;
                const endX = this.x + Math.cos(this.targetAngle) * this.range;
                const endY = this.y + Math.sin(this.targetAngle) * this.range;
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 8;
                ctx.shadowBlur = 25;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(endX, endY);
                ctx.stroke();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(endX, endY);
                ctx.stroke();
            }
            
            getLaserEndpoint() {
                return {
                    x: this.x + Math.cos(this.targetAngle) * this.range,
                    y: this.y + Math.sin(this.targetAngle) * this.range
                };
            }
        }
        
        class Alien {
            constructor(dxData, tier, isTarget) {
                const angle = Math.random() * Math.PI * 2;
                const r = arenaRadius + 25;
                this.x = center.x + Math.cos(angle) * r;
                this.y = center.y + Math.sin(angle) * r;
                
                // SPEED SCALING BASED ON DIFFICULTY
                let speedMult = 1.0;
                if (difficulty === 'medium') speedMult = 1.4;
                if (difficulty === 'hard') speedMult = 1.8;
                
                this.speed = (0.8 + Math.random()) * speedMult;
                this.radius = 24;
                this.code = dxData.code;
                this.dxData = dxData;
                this.isTarget = isTarget;
                this.maxHealth = isTarget ? tier + 1 : tier;
                this.health = this.maxHealth;
                this.dead = false;
                this.pulse = Math.random() * Math.PI;
                
                if (dxData.isHCC) {
                    this.color = '#ffd700';
                    this.baseColor = '#ffd700';
                } else if (dxData.advancesSharedSavings) {
                    this.color = '#00f5ff';
                    this.baseColor = '#00f5ff';
                } else {
                    this.color = '#39ff14';
                    this.baseColor = '#39ff14';
                }
            }
            
            update() {
                const dx = center.x - this.x;
                const dy = center.y - this.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist > 35) {
                    this.x += (dx/dist) * this.speed;
                    this.y += (dy/dist) * this.speed;
                } else {
                    // DAMAGE SCALING
                    let dmgMult = 1.0;
                    if (difficulty === 'hard') dmgMult = 1.5;
                    
                    const dmg = (this.dxData.isHCC ? 40 : 15) * dmgMult;
                    coreHealth -= dmg; 
                    this.dead = true;
                    createExplosion(this.x, this.y, '#ff0000');
                    showWarning(this.dxData.isHCC ? "HCC TARGET LOST!" : "CODE MISSED!", "left");
                }
                cannons.forEach(c => {
                    const cdx = this.x - c.x;
                    const cdy = this.y - c.y;
                    if (Math.sqrt(cdx*cdx + cdy*cdy) < 28) {
                        c.integrity -= 15;
                        this.health--;
                        if (this.health <= 0) this.dead = true;
                        createExplosion(this.x, this.y, '#ffaa00');
                    }
                });
                this.pulse += 0.12;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                if (this.dxData.isHCC) {
                    ctx.shadowBlur = 25 + Math.sin(this.pulse*3)*10;
                    ctx.shadowColor = '#ffd700';
                    ctx.strokeStyle = `rgba(255, 215, 0, ${0.4 + Math.sin(this.pulse)*0.3})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius + 22, 0, Math.PI*2);
                    ctx.stroke();
                    
                    // MODIFIED: Show Code + HCC Weight for clear identification
                    ctx.fillStyle = '#ffd700';
                    ctx.font = 'bold 10px "Courier New", monospace';
                    ctx.textAlign = 'center';
                    // Label change here
                    ctx.fillText(`${this.code} (HCC ${this.dxData.hccWeight})`, 0, this.radius + 22);
                } 
                
                if (this.dxData.advancesSharedSavings) {
                    ctx.strokeStyle = `rgba(0, 245, 255, ${0.3 + Math.sin(this.pulse)*0.2})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    const spikes = 8;
                    const outerRadius = this.radius + 18;
                    const innerRadius = this.radius + 10;
                    let rot = Math.PI / 2 * 3;
                    let cx = 0, cy = 0;
                    let x = cx, y = cy;
                    let step = Math.PI / spikes;

                    ctx.moveTo(cx, cy - outerRadius);
                    for (let i = 0; i < spikes; i++) {
                        x = cx + Math.cos(rot) * outerRadius;
                        y = cy + Math.sin(rot) * outerRadius;
                        ctx.lineTo(x, y);
                        rot += step;

                        x = cx + Math.cos(rot) * innerRadius;
                        y = cy + Math.sin(rot) * innerRadius;
                        ctx.lineTo(x, y);
                        rot += step;
                    }
                    ctx.lineTo(cx, cy - outerRadius);
                    ctx.closePath();
                    ctx.stroke();
                }
                
                const scale = 1 + Math.sin(this.pulse)*0.05;
                ctx.scale(scale, scale);
                const hpPct = this.health / this.maxHealth;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius + 10, -Math.PI/2, -Math.PI/2 + (Math.PI*2*hpPct));
                ctx.strokeStyle = this.health === 1 ? '#ff0000' : this.baseColor;
                ctx.lineWidth = 3;
                ctx.stroke();
                
                ctx.fillStyle = this.color;
                ctx.shadowBlur = this.isTarget ? 20 : 15;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI*2);
                ctx.fill();
                
                ctx.fillStyle = this.dxData.isHCC ? '#000' : 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.arc(0, 0, this.radius*0.65, 0, Math.PI*2);
                ctx.fill();
                
                ctx.fillStyle = this.dxData.isHCC ? '#000' : '#fff';
                ctx.shadowBlur = 0;
                ctx.font = `bold ${this.isTarget ? 11 : 9}px "Courier New", monospace`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const parts = this.code.split('.');
                if (parts.length > 1) {
                    ctx.fillText(parts[0], 0, -4);
                    ctx.fillText('.' + parts[1], 0, 6);
                } else {
                    ctx.fillText(this.code, 0, 1);
                }
                
                ctx.restore();
            }
        }
        
        function createExplosion(x, y, color) {
            for (let i=0; i<12; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random()-0.5)*10,
                    vy: (Math.random()-0.5)*10,
                    life: 1,
                    color: color,
                    size: Math.random()*5+2
                });
            }
        }
        
        function showWarning(text, flank) {
            const container = document.getElementById('warning-container');
            const div = document.createElement('div');
            div.className = `warning ${flank || 'right'}-flank`;
            div.textContent = text;
            container.appendChild(div);
            setTimeout(() => div.remove(), 1000);
        }
        
        function addBonusWord(dxData) {
            const code = dxData.code;
            const now = Date.now();
            
            if (!vocabularyBank[code]) {
                vocabularyBank[code] = { 
                    mastery: 0, 
                    hits: 0, 
                    lastSeen: now, 
                    dxData: dxData,
                    hccWeight: dxData.hccWeight,
                    solidified: false
                };
            }
            
            const entry = vocabularyBank[code];
            entry.hits++;
            entry.lastSeen = now;
            
            let gain = 25;
            if (entry.hits > 1) gain = 15;
            if (entry.hits > 3) gain = 10;
            if (entry.hits > 6) gain = 5;
            
            entry.mastery = Math.min(100, entry.mastery + gain);
            saveVocabulary(vocabularyBank);
            speakClinicalData(dxData);
            triggerCentralFeedback(dxData);
        }
        
        function decayVocabularyRealtime() {
            decayFrameCounter++;
            if (decayFrameCounter % 60 !== 0) return;
            
            saveLastDecayTime();
            
            for (let code in vocabularyBank) {
                const entry = vocabularyBank[code];
                if (entry.mastery <= 0) continue;
                
                let secondDecay = entry.mastery >= 70 ? 0.0008 : (entry.mastery >= 30 ? 0.005 : 0.016);
                
                if (entry.solidified) secondDecay *= 0.1; // Solidified memories are tough
                if (entry.hccWeight > 0) secondDecay *= (1.0 / (1.0 + entry.hccWeight));
                
                entry.mastery = Math.max(0, entry.mastery - secondDecay);
            }
        }
        
        function drawInfoPanel() {
            infoCtx.fillStyle = '#050508';
            infoCtx.fillRect(0, 0, 380, 900);
            infoCtx.strokeStyle = '#0f0f1a';
            infoCtx.lineWidth = 1;
            
            for(let i=0; i<380; i+=25) { infoCtx.beginPath(); infoCtx.moveTo(i,0); infoCtx.lineTo(i,900); infoCtx.stroke(); }
            for(let i=0; i<900; i+=25) { infoCtx.beginPath(); infoCtx.moveTo(0,i); infoCtx.lineTo(380,i); infoCtx.stroke(); }
            
            let yPos = 30;
            infoCtx.fillStyle = '#00f5ff';
            infoCtx.shadowBlur = 10;
            infoCtx.shadowColor = '#00f5ff';
            infoCtx.font = 'bold 22px "Courier New", monospace';
            infoCtx.textAlign = 'center';
            infoCtx.fillText('CLINICAL TARGET', 190, yPos);
            yPos += 45;
            
            if (currentTarget) {
                const code = currentTarget.code;
                const vocabEntry = vocabularyBank[code];
                const mastery = vocabEntry ? vocabEntry.mastery : 0;
                
                infoCtx.fillStyle = currentTarget.isHCC ? '#ffd700' : '#00f5ff';
                infoCtx.shadowBlur = 20;
                infoCtx.shadowColor = infoCtx.fillStyle;
                infoCtx.font = 'bold 48px "Courier New", monospace';
                infoCtx.fillText(code, 190, yPos);
                yPos += 30;
                
                // Switch timer bar
                const maxTime = gameSettings.targetDuration * 60;
                const timerPct = targetSwitchTimer / maxTime;
                infoCtx.fillStyle = '#333';
                infoCtx.fillRect(90, yPos, 200, 4);
                infoCtx.fillStyle = '#ff6600';
                infoCtx.fillRect(90, yPos, 200 * (1-timerPct), 4);
                yPos += 35;
                
                infoCtx.fillStyle = '#fff';
                infoCtx.shadowBlur = 0;
                infoCtx.font = 'bold 16px "Segoe UI", sans-serif';
                infoCtx.fillText(currentTarget.dx.toUpperCase(), 190, yPos);
                yPos += 35;
                
                if (currentTarget.isHCC) {
                    infoCtx.fillStyle = '#ffd700';
                    infoCtx.shadowBlur = 15;
                    infoCtx.shadowColor = '#ffd700';
                    infoCtx.fillRect(90, yPos - 20, 200, 28);
                    infoCtx.fillStyle = '#000';
                    infoCtx.font = 'bold 16px "Courier New", monospace';
                    infoCtx.fillText(`★ HCC WEIGHT: ${currentTarget.hccWeight} ★`, 190, yPos);
                    yPos += 35;
                }
                
                if (currentTarget.advancesSharedSavings) {
                    infoCtx.fillStyle = '#39ff14';
                    infoCtx.shadowBlur = 10;
                    infoCtx.shadowColor = '#39ff14';
                    infoCtx.fillRect(80, yPos - 18, 220, 24);
                    infoCtx.fillStyle = '#000';
                    infoCtx.font = 'bold 12px "Courier New", monospace';
                    infoCtx.fillText('◆ ADVANCES SHARED SAVINGS ◆', 190, yPos + 2);
                    yPos += 35;
                }
                
                yPos += 10;
                infoCtx.fillStyle = '#ff006e';
                infoCtx.font = 'bold 14px "Courier New", monospace';
                infoCtx.fillText('CRITICAL CLINICAL FACTS:', 30, yPos);
                yPos += 25;
                
                infoCtx.font = '13px "Segoe UI", sans-serif';
                currentTarget.criticalFacts.forEach((fact, idx) => {
                    if (idx % 2 === 0) {
                        infoCtx.fillStyle = 'rgba(255,255,255,0.05)';
                        infoCtx.fillRect(25, yPos - 15, 330, 22);
                    }
                    infoCtx.fillStyle = '#aaa';
                    infoCtx.textAlign = 'left';
                    infoCtx.fillStyle = currentTarget.isHCC ? '#ffd700' : '#00f5ff';
                    infoCtx.fillText('•', 30, yPos);
                    infoCtx.fillStyle = '#ddd';
                    const words = fact.split(' ');
                    let line = '';
                    let xOffset = 45;
                    for (let word of words) {
                        const testLine = line + word + ' ';
                        const metrics = infoCtx.measureText(testLine);
                        if (metrics.width > 310 && line !== '') {
                            infoCtx.fillText(line, xOffset, yPos);
                            line = word + ' ';
                            yPos += 18;
                            xOffset = 45;
                        } else {
                            line = testLine;
                        }
                    }
                    infoCtx.fillText(line, xOffset, yPos);
                    yPos += 22;
                });
                yPos += 20;
            }
            
            infoCtx.strokeStyle = '#ffd700';
            infoCtx.lineWidth = 2;
            infoCtx.beginPath();
            infoCtx.moveTo(30, yPos);
            infoCtx.lineTo(350, yPos);
            infoCtx.stroke();
            yPos += 35;
            
            // --- MODIFIED SCORING DISPLAY ---
            
            // Calculate RAF (Total Known x HCC Score)
            // Base RAF of 0.5 + Sum of (Code Mastery% * Weight) or just Sum of Weights of Mastered Codes
            // Prompt says: "knowledge score is weighted by total known x hcc score"
            // Let's implement: Base 0.500 + Sum(HCC Weight) for all solidified codes + (0.1 * Sum(HCC Weight) for active learned codes > 70%)
            let calculatedRAF = 0.5;
            let masteredCount = 0;
            
            Object.values(vocabularyBank).forEach(v => {
                if (v.solidified) {
                    calculatedRAF += v.hccWeight;
                    masteredCount++;
                } else if (v.mastery > 70) {
                    calculatedRAF += (v.hccWeight * 0.5); // Partial credit
                }
            });

            infoCtx.fillStyle = '#39ff14';
            infoCtx.shadowBlur = 15;
            infoCtx.shadowColor = '#39ff14';
            infoCtx.font = 'bold 32px "Courier New", monospace';
            infoCtx.textAlign = 'center';
            infoCtx.fillText('RAF SCORE: ' + calculatedRAF.toFixed(3), 190, yPos);
            yPos += 25;

            // Show Arcade Score smaller
            infoCtx.fillStyle = '#fff';
            infoCtx.font = 'bold 16px "Courier New", monospace';
            infoCtx.fillText('PROTOCOL PTS: ' + score, 190, yPos);
            yPos += 30;
            
            infoCtx.fillStyle = coreHealth < 30 ? '#ff0000' : '#00f5ff';
            infoCtx.shadowBlur = coreHealth < 30 ? 20 : 10;
            infoCtx.shadowColor = coreHealth < 30 ? '#ff0000' : '#00f5ff';
            infoCtx.font = 'bold 18px "Courier New", monospace';
            infoCtx.fillText('CLINICAL INTEGRITY: ' + Math.floor(coreHealth) + '%', 190, yPos);
            yPos += 60;
            
            // --- SPLIT REPOSITORY SECTION ---
            
            // Reset click regions
            infoPanelClickRegions = [];

            const allVocab = Object.entries(vocabularyBank).filter(([code, data]) => data.mastery > 5);
            const solidifiedItems = allVocab.filter(([code, data]) => data.solidified).sort((a,b) => b[1].mastery - a[1].mastery);
            const learningItems = allVocab.filter(([code, data]) => !data.solidified).sort((a,b) => b[1].mastery - a[1].mastery);

            // Helper to draw items
            const drawRepoItems = (items, startY) => {
                let x = 100;
                let rowY = startY;
                items.slice(0, 4).forEach(([code, data], index) => {
                    const isSolid = data.solidified;
                    const isHCC = data.dxData.isHCC;
                    
                    // Draw box/ring
                    infoCtx.fillStyle = isSolid ? '#000' : '#1a1a2e';
                    infoCtx.fillRect(x - 80, rowY - 20, 160, 40);
                    
                    // MODIFIED: All HCCs get yellow glow/border
                    if (isHCC) {
                        infoCtx.strokeStyle = '#ffd700';
                        infoCtx.lineWidth = isSolid ? 3 : 2;
                        infoCtx.shadowBlur = 15;
                        infoCtx.shadowColor = '#ffd700';
                        infoCtx.strokeRect(x - 82, rowY - 22, 164, 44);
                    } else if (isSolid) {
                        infoCtx.strokeStyle = '#00f5ff'; // Solid non-HCC
                        infoCtx.lineWidth = 3;
                        infoCtx.shadowBlur = 15;
                        infoCtx.shadowColor = '#00f5ff';
                        infoCtx.strokeRect(x - 82, rowY - 22, 164, 44);
                    } else {
                        infoCtx.strokeStyle = data.mastery > 70 ? '#39ff14' : '#00f5ff';
                        infoCtx.lineWidth = 1;
                        infoCtx.shadowBlur = 0;
                        infoCtx.strokeRect(x - 80, rowY - 20, 160, 40);
                    }
                    
                    // Memory Line (Progress Bar)
                    const memPct = data.mastery / 100;
                    infoCtx.fillStyle = data.mastery > 70 ? '#39ff14' : (data.mastery > 30 ? '#00f5ff' : '#ff006e');
                    infoCtx.shadowBlur = 5;
                    infoCtx.shadowColor = infoCtx.fillStyle;
                    infoCtx.fillRect(x - 80, rowY + 16, 160 * memPct, 4);

                    // Register Click Region
                    infoPanelClickRegions.push({
                        x: x - 80,
                        y: rowY - 20,
                        width: 160,
                        height: 40,
                        code: code
                    });

                    // Draw Code
                    infoCtx.fillStyle = isHCC ? '#ffd700' : (isSolid ? '#fff' : '#fff');
                    infoCtx.shadowBlur = isSolid ? 10 : 0;
                    infoCtx.font = 'bold 24px "Courier New", monospace';
                    infoCtx.textAlign = 'center';
                    infoCtx.fillText(code, x, rowY + 8);
                    
                    if (index % 2 === 0) {
                        x += 180;
                    } else {
                        x = 100;
                        rowY += 60;
                    }
                });
                return rowY + 60; // Return next Y
            };

            // Draw Solidified Section
            infoCtx.textAlign = 'center';
            infoCtx.fillStyle = '#ffd700';
            infoCtx.shadowBlur = 10;
            infoCtx.shadowColor = '#ffd700';
            infoCtx.font = 'bold 16px "Courier New", monospace';
            infoCtx.fillText('SOLIDIFIED PROTOCOLS', 190, yPos);
            yPos += 35;

            if (solidifiedItems.length > 0) {
                drawRepoItems(solidifiedItems, yPos);
                const rows = Math.ceil(Math.min(solidifiedItems.length, 4) / 2);
                yPos += rows * 60;
            } else {
                infoCtx.fillStyle = '#666';
                infoCtx.font = 'italic 12px "Segoe UI", sans-serif';
                infoCtx.shadowBlur = 0;
                infoCtx.fillText('No protocols solidified yet.', 190, yPos);
                yPos += 40;
            }

            yPos += 20;

            // Draw Learning Section
            infoCtx.fillStyle = '#00f5ff';
            infoCtx.shadowBlur = 10;
            infoCtx.shadowColor = '#00f5ff';
            infoCtx.font = 'bold 16px "Courier New", monospace';
            infoCtx.fillText('ACTIVE LEARNING', 190, yPos);
            yPos += 35;

            if (learningItems.length > 0) {
                drawRepoItems(learningItems, yPos);
            } else {
                infoCtx.fillStyle = '#666';
                infoCtx.font = 'italic 12px "Segoe UI", sans-serif';
                infoCtx.shadowBlur = 0;
                infoCtx.fillText('No active data.', 190, yPos);
            }
        }
        
        function getIntersection(c1, c2) {
            const x1=c1.x, y1=c1.y, x2=c1.x+Math.cos(c1.targetAngle)*c1.range;
            const y2=c1.y+Math.sin(c1.targetAngle)*c1.range;
            const x3=c2.x, y3=c2.y, x4=c2.x+Math.cos(c2.targetAngle)*c2.range;
            const y4=c2.y+Math.sin(c2.targetAngle)*c2.range;
            const denom = (x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);
            if (Math.abs(denom)<0.001) return null;
            const t = ((x1-x3)*(y3-y4)-(y1-y3)*(x3-x4))/denom;
            const u = -((x1-x2)*(y1-y3)-(y1-y2)*(x1-x3))/denom;
            if (t>=0 && t<=1 && u>=0 && u<=1) return {x:x1+t*(x2-x1), y:y1+t*(y2-y1)};
            return null;
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }
        
        function startGame(diff) {
            difficulty = diff;
            gameState = 'playing';
            
            // poolSize logic
            let poolSize = 3; // default
            if (diff === 'medium') poolSize = 6;
            if (diff === 'hard') poolSize = 12;
            
            let shuffledDb = shuffleArray([...icdDatabase]);
            const allDxWithMastery = shuffledDb.map(dx => {
                const vocab = vocabularyBank[dx.code];
                return {
                    ...dx,
                    currentMastery: vocab ? vocab.mastery : 0,
                    needsRenewal: vocab && vocab.mastery > 0 && vocab.mastery < 30,
                    isLearned: vocab && vocab.mastery > 70
                };
            });
            
            activePool = allDxWithMastery.slice(0, poolSize);
            
            targetIndex = 0;
            currentTarget = activePool[0];
            targetSwitchTimer = gameSettings.targetDuration * 60;
            
            cannons.length = 0;
            for (let i=0; i<6; i++) cannons.push(new Cannon(i, 6));
            
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('health-bar').classList.remove('hidden');
            document.getElementById('core-label').classList.remove('hidden');
            document.getElementById('controls-hint').classList.remove('hidden');
            
            if (window.gameInterval) clearInterval(window.gameInterval);
            window.gameInterval = setInterval(() => { if (gameState === 'playing') update(); }, 1000/60);
            
            // Initial Warning
            showWarning(`TARGET: ${currentTarget.code}`, "right");
            triggerCentralFeedback(currentTarget);
            
            draw();
        }

        function downloadCertificate() {
            const certCanvas = document.createElement('canvas');
            certCanvas.width = 800;
            certCanvas.height = 600;
            const cCtx = certCanvas.getContext('2d');

            cCtx.fillStyle = '#f8f9fa';
            cCtx.fillRect(0, 0, 800, 600);
            cCtx.strokeStyle = '#1a1a2e';
            cCtx.lineWidth = 15;
            cCtx.strokeRect(20, 20, 760, 560);
            cCtx.strokeStyle = '#ffd700';
            cCtx.lineWidth = 5;
            cCtx.strokeRect(30, 30, 740, 540);

            cCtx.fillStyle = '#050508';
            cCtx.textAlign = 'center';
            cCtx.font = 'bold 40px "Times New Roman", serif';
            cCtx.fillText('CERTIFICATE OF CLINICAL MASTERY', 400, 100);
            cCtx.font = '24px "Times New Roman", serif';
            cCtx.fillText('INTERNIST DIVISION - ICD-10 PROTOCOL', 400, 150);

            cCtx.font = 'italic 20px "Arial", sans-serif';
            cCtx.fillText('This certifies that the authorized user has demonstrated proficiency in', 400, 220);
            cCtx.fillText('Risk Adjustment Coding and Shared Savings Documentation.', 400, 250);

            const hccCaptured = Object.values(vocabularyBank).filter(v => v.dxData.isHCC && v.mastery >= 70).length;
            const dateStr = new Date().toLocaleDateString();

            // Calculate RAF for Cert
            let finalRAF = 0.5;
            Object.values(vocabularyBank).forEach(v => {
                if (v.solidified) finalRAF += v.hccWeight;
                else if (v.mastery > 70) finalRAF += (v.hccWeight * 0.5);
            });

            cCtx.font = 'bold 30px "Courier New", monospace';
            cCtx.fillStyle = '#ff006e';
            cCtx.fillText(`FINAL RAF SCORE: ${finalRAF.toFixed(3)}`, 400, 340);
            cCtx.fillStyle = '#00f5ff';
            cCtx.fillText(`HCC CODES MASTERED: ${hccCaptured}`, 400, 390);

            cCtx.fillStyle = '#333';
            cCtx.font = '18px "Arial", sans-serif';
            cCtx.fillText(`Date Issued: ${dateStr}`, 400, 480);

            cCtx.beginPath();
            cCtx.moveTo(250, 520);
            cCtx.lineTo(550, 520);
            cCtx.strokeStyle = '#000';
            cCtx.lineWidth = 2;
            cCtx.stroke();
            cCtx.font = '16px "Arial", sans-serif';
            cCtx.fillText('CLINICAL CIRCUMFERENCE ADMINISTRATOR', 400, 545);

            const link = document.createElement('a');
            link.download = 'clinical-circumference-certificate.png';
            link.href = certCanvas.toDataURL();
            link.click();
        }
        
        function update() {
            frame++;
            decayVocabularyRealtime();
            
            // Update Central Feedback Timer
            if (centralFeedback.active) {
                centralFeedback.timer--;
                if (centralFeedback.timer <= 0) centralFeedback.active = false;
            }

            // MODIFIED: Use variable rotation speed
            if (keys['KeyA']) baseRotation -= gameSettings.rotationSpeed;
            if (keys['KeyS']) baseRotation += gameSettings.rotationSpeed;

            // TARGET SWITCHING LOGIC
            targetSwitchTimer--;
            if (targetSwitchTimer <= 0) {
                targetIndex = (targetIndex + 1) % activePool.length;
                currentTarget = activePool[targetIndex];
                targetSwitchTimer = gameSettings.targetDuration * 60; // Use settings
                
                // MODIFIED: More detailed target feedback
                const hccMsg = currentTarget.isHCC ? " [HCC]" : "";
                showWarning(`${currentTarget.code} ${currentTarget.dx}${hccMsg}`, "right");
                triggerCentralFeedback(currentTarget);
            }
            
            // DIFFICULTY: MAX ALIEN COUNT SCALING
            let maxAliens = 12;
            let spawnRate = 100;
            
            if (difficulty === 'medium') { maxAliens = 18; spawnRate = 80; }
            if (difficulty === 'hard') { maxAliens = 25; spawnRate = 50; }
            
            if (frame % spawnRate === 0 && aliens.length < maxAliens) {
                const isTarget = Math.random() < 0.3;
                let dxData;
                if (isTarget) dxData = currentTarget;
                else {
                    let idx;
                    do { idx = Math.floor(Math.random()*activePool.length); }
                    while (activePool[idx].code === currentTarget.code);
                    dxData = activePool[idx];
                }
                
                let tier = 1;
                if (difficulty === 'medium' && Math.random()>0.6) tier=2;
                if (difficulty === 'hard') {
                    const r=Math.random();
                    if (r>0.7) tier=3;
                    else if (r>0.4) tier=2;
                }
                aliens.push(new Alien(dxData, tier, isTarget));
            }
            
            cannons.forEach(c => c.update());
            
            const intersections = [];
            for (let i=0; i<cannons.length; i++) {
                for (let j=i+1; j<cannons.length; j++) {
                    if (cannons[i].firing && cannons[j].firing && cannons[i].integrity>0 && cannons[j].integrity>0) {
                        const pt = getIntersection(cannons[i], cannons[j]);
                        if (pt) intersections.push(pt);
                    }
                }
            }
            
            cannons.forEach(shooter => {
                if (!shooter.firing || shooter.integrity <= 0) return;
                const end = shooter.getLaserEndpoint();
                cannons.forEach(target => {
                    if (target === shooter || target.integrity <= 0) return;
                    const dx = end.x - shooter.x;
                    const dy = end.y - shooter.y;
                    const lenSq = dx*dx + dy*dy;
                    if (lenSq === 0) return;
                    const t = Math.max(0, Math.min(1, ((target.x - shooter.x) * dx + (target.y - shooter.y) * dy) / lenSq));
                    const closestX = shooter.x + t * dx;
                    const closestY = shooter.y + t * dy;
                    const dist = Math.hypot(target.x - closestX, target.y - closestY);
                    if (dist < 25) {
                        target.integrity -= 0.4;
                        target.friendlyFireDamage += 0.4;
                        if (frame % 5 === 0) createExplosion(closestX, closestY, '#ff6600');
                        if (target.friendlyFireDamage > 20 && friendlyFireWarningCooldown === 0) {
                            showWarning("FRIENDLY FIRE!", "right");
                            friendlyFireWarningCooldown = 120;
                        }
                    }
                });
            });
            if (friendlyFireWarningCooldown > 0) friendlyFireWarningCooldown--;
            
            intersections.forEach(pt => {
                if (Math.hypot(pt.x-center.x, pt.y-center.y) < 65) coreHealth -= 0.4;
            });
            
            aliens.forEach(alien => {
                alien.update();
                cannons.forEach(c => {
                    if (!c.firing || c.integrity<=0) return;
                    const dx = Math.cos(c.targetAngle);
                    const dy = Math.sin(c.targetAngle);
                    const t = ((alien.x-c.x)*dx + (alien.y-c.y)*dy);
                    if (t>0 && t<c.range) {
                        const cx = c.x + dx*t;
                        const cy = c.y + dy*t;
                        const dist = Math.hypot(alien.x-cx, alien.y-cy);
                        if (dist < alien.radius+6) {
                            alien.health -= 0.4;
                            if (alien.health<=0 && !alien.dead) {
                                alien.dead = true;
                                if (alien.isTarget) {
                                    if (alien.dxData.isHCC) {
                                        const hccBonus = Math.floor(100 * (1 + (alien.dxData.hccWeight * 2)));
                                        score += hccBonus;
                                    } else {
                                        score += 15;
                                    }
                                    
                                    coreHealth = Math.min(100, coreHealth+20);
                                    addBonusWord(alien.dxData);
                                    createExplosion(alien.x, alien.y, '#ffd700');
                                    // Target switching is now handled by timer, not destruction
                                } else {
                                    score += 10;
                                    createExplosion(alien.x, alien.y, alien.color);
                                }
                            }
                        }
                    }
                });
                intersections.forEach(pt => {
                    if (Math.hypot(alien.x-pt.x, alien.y-pt.y) < 45 && !alien.dead) {
                        alien.dead = true;
                        if (alien.isTarget) {
                            if (alien.dxData.isHCC) {
                                const hccBonus = Math.floor(150 * (1 + (alien.dxData.hccWeight * 2)));
                                score += hccBonus;
                            } else {
                                score += 20;
                            }
                            coreHealth = Math.min(100, coreHealth+30);
                            addBonusWord(alien.dxData);
                            createExplosion(alien.x, alien.y, '#ffd700');
                        } else {
                            score += 25;
                            createExplosion(alien.x, alien.y, '#ffcc00');
                        }
                    }
                });
            });
            
            for (let i=aliens.length-1; i>=0; i--) if (aliens[i].dead) aliens.splice(i,1);
            for (let i=particles.length-1; i>=0; i--) {
                const p=particles[i];
                p.x+=p.vx; p.y+=p.vy; p.life-=0.025; p.vx*=0.95; p.vy*=0.95;
                if (p.life<=0) particles.splice(i,1);
            }
            
            document.getElementById('health-fill').style.width = Math.max(0,coreHealth)+'%';
            
            if (coreHealth<=0) {
                gameState = 'gameover';
                const hccCaptured = Object.values(vocabularyBank).filter(v => v.dxData.isHCC && v.mastery >= 70).length;
                document.getElementById('game-over-screen').classList.remove('hidden');
                
                // Calculate Final RAF
                let finalRAF = 0.5;
                Object.values(vocabularyBank).forEach(v => {
                    if (v.solidified) finalRAF += v.hccWeight;
                    else if (v.mastery > 70) finalRAF += (v.hccWeight * 0.5);
                });

                document.getElementById('final-score').textContent = `Final RAF Score: ${finalRAF.toFixed(3)}`;
                document.getElementById('final-words').textContent = `HCC Captured: ${hccCaptured}`;
            }
        }
        
        function draw() {
            ctx.fillStyle = '#050508';
            ctx.fillRect(0,0,900,900);
            ctx.strokeStyle = '#1a1a2e';
            ctx.lineWidth = 3;
            ctx.setLineDash([12,12]);
            ctx.beginPath();
            ctx.arc(center.x, center.y, arenaRadius, 0, Math.PI*2);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.strokeStyle = '#0f0f1a';
            ctx.lineWidth = 1;
            for(let i=0; i<900; i+=50) {
                ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,900); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(900,i); ctx.stroke();
            }
            
            if (gameState==='playing') {
                cannons.forEach((c1,i) => {
                    cannons.forEach((c2,j) => {
                        if (i<j && c1.firing && c2.firing && c1.integrity>0 && c2.integrity>0) {
                            const pt = getIntersection(c1,c2);
                            if (pt) {
                                const pulse = Math.sin(frame*0.4)*6;
                                ctx.fillStyle = '#ffaa00';
                                ctx.shadowBlur = 35;
                                ctx.shadowColor = '#ff6600';
                                ctx.beginPath();
                                ctx.arc(pt.x, pt.y, 28+pulse, 0, Math.PI*2);
                                ctx.fill();
                                ctx.fillStyle = '#fff';
                                ctx.beginPath();
                                ctx.arc(pt.x, pt.y, 10, 0, Math.PI*2);
                                ctx.fill();
                            }
                        }
                    });
                });
            }
            
            cannons.forEach(c => c.drawLaser());
            ctx.shadowBlur = 40;
            ctx.shadowColor = '#00f5ff';
            ctx.fillStyle = '#00f5ff';
            ctx.beginPath(); ctx.arc(center.x, center.y, 32, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(center.x, center.y, 45, -Math.PI/2, -Math.PI/2+(Math.PI*2*(coreHealth/100)));
            ctx.strokeStyle = coreHealth<30?'#ff0000':'#00f5ff';
            ctx.lineWidth = 4; ctx.stroke();
            ctx.fillStyle = '#fff';
            ctx.beginPath(); ctx.arc(center.x, center.y, 16, 0, Math.PI*2); ctx.fill();
            
            // Draw Central Feedback Overlay
            if (centralFeedback.active) {
                ctx.save();
                ctx.translate(center.x, center.y);
                
                // Box background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                ctx.strokeStyle = '#00f5ff';
                ctx.lineWidth = 2;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#00f5ff';
                
                // Centered Rect
                ctx.beginPath();
                ctx.rect(-150, -50, 300, 100);
                ctx.fill();
                ctx.stroke();
                
                // Text
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Code
                ctx.font = 'bold 36px "Courier New", monospace';
                ctx.fillStyle = '#ffd700';
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 10;
                ctx.fillText(centralFeedback.code, 0, -15);
                
                // Diagnosis
                ctx.font = 'bold 14px "Segoe UI", sans-serif';
                ctx.fillStyle = '#fff';
                ctx.shadowBlur = 0;
                ctx.fillText(centralFeedback.dx.toUpperCase(), 0, 20);
                
                ctx.restore();
            }

            cannons.forEach(c => c.draw());
            aliens.forEach(a => a.draw());
            ctx.globalAlpha = 1;
            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = p.color;
                ctx.fillRect(p.x-p.size/2, p.y-p.size/2, p.size, p.size);
            });
            ctx.globalAlpha = 1;
            drawInfoPanel();
            if (gameState === 'playing') requestAnimationFrame(draw);
        }
    </script>
</body>
</html>
